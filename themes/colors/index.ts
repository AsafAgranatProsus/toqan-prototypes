/**
 * Theme Color Registry
 * 
 * This module provides a registry of available theme color files
 * for use with the Toqan Theme Loader.
 * 
 * Themes are loaded from the manifest file (public/themes/themes.json)
 * which is the single source of truth for available themes.
 * 
 * Theme files are CSS files containing --color-* token definitions
 * for both light and dark modes. They are generated by the M3 Theme Builder.
 */

export interface ThemeMetadata {
  /** Unique identifier for the theme */
  id: string;
  /** Display name for the theme */
  name: string;
  /** Brief description of the theme */
  description?: string;
  /** Source color used to generate the theme */
  sourceColor?: string;
  /** CSS filename (without path) */
  filename: string;
  /** Whether this is the default theme */
  isDefault?: boolean;
  /** Theme author or origin */
  author?: string;
  /** Date the theme was created/modified */
  createdAt?: string;
  /** Display/heading font family */
  displayFont?: string;
  /** Body/text font family */
  bodyFont?: string;
  /** Contrast level (0 = standard, 0.5 = medium, 1 = high) */
  contrastLevel?: number;
}

interface ThemeManifest {
  themes: ThemeMetadata[];
}

// Cache for loaded themes
let cachedThemes: ThemeMetadata[] | null = null;
let loadPromise: Promise<ThemeMetadata[]> | null = null;

/**
 * Load theme manifest from JSON file
 * 
 * This is the primary way to get available themes.
 * Results are cached after first load.
 */
export async function loadThemeManifest(): Promise<ThemeMetadata[]> {
  // Return cached themes if available
  if (cachedThemes) {
    return cachedThemes;
  }
  
  // If already loading, wait for that promise
  if (loadPromise) {
    return loadPromise;
  }
  
  // Start loading
  loadPromise = fetch('/themes/themes.json')
    .then(response => {
      if (!response.ok) {
        throw new Error(`Failed to load theme manifest: ${response.status}`);
      }
      return response.json();
    })
    .then((manifest: ThemeManifest) => {
      cachedThemes = manifest.themes;
      return cachedThemes;
    })
    .catch(error => {
      console.error('[ThemeRegistry] Failed to load manifest:', error);
      // Fallback to default theme only
      cachedThemes = [{
        id: 'default',
        name: 'Default',
        description: 'The default Toqan theme',
        filename: '',
        isDefault: true,
      }];
      return cachedThemes;
    })
    .finally(() => {
      loadPromise = null;
    });
  
  return loadPromise;
}

/**
 * Get themes synchronously (returns cached or empty array)
 * Use loadThemeManifest() for async loading.
 */
export function getThemesSync(): ThemeMetadata[] {
  return cachedThemes || [];
}

/**
 * Get theme by ID
 */
export async function getThemeById(id: string): Promise<ThemeMetadata | undefined> {
  const themes = await loadThemeManifest();
  return themes.find(theme => theme.id === id);
}

/**
 * Get theme by ID (sync version, uses cache)
 */
export function getThemeByIdSync(id: string): ThemeMetadata | undefined {
  const themes = getThemesSync();
  return themes.find(theme => theme.id === id);
}

/**
 * Get the default theme
 */
export async function getDefaultTheme(): Promise<ThemeMetadata | undefined> {
  const themes = await loadThemeManifest();
  return themes.find(theme => theme.isDefault) || themes[0];
}

/**
 * Load Google Fonts dynamically
 */
function loadGoogleFonts(fonts: string[]): void {
  // Remove existing theme fonts link
  const existingLink = document.getElementById('theme-fonts-link');
  if (existingLink) {
    existingLink.remove();
  }
  
  if (fonts.length === 0) return;
  
  // Create Google Fonts URL
  const fontParams = fonts.map(font => 
    `family=${encodeURIComponent(font)}:wght@400;500;600;700`
  ).join('&');
  
  const link = document.createElement('link');
  link.id = 'theme-fonts-link';
  link.rel = 'stylesheet';
  link.href = `https://fonts.googleapis.com/css2?${fontParams}&display=swap`;
  document.head.appendChild(link);
}

/**
 * Apply font CSS variables
 */
function applyFontVariables(displayFont?: string, bodyFont?: string): void {
  if (displayFont) {
    document.documentElement.style.setProperty(
      '--font-family-default',
      `'${displayFont}', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`
    );
  }
  if (bodyFont) {
    document.documentElement.style.setProperty(
      '--font-family-serif',
      `'${bodyFont}', Georgia, 'Times New Roman', serif`
    );
  }
}

/**
 * Load a theme's CSS file dynamically
 * 
 * @param theme - Theme metadata
 * @returns Promise that resolves when the theme is loaded
 */
export async function loadTheme(theme: ThemeMetadata): Promise<void> {
  // Remove any previously loaded custom theme
  const existingLink = document.getElementById('custom-theme-css');
  if (existingLink) {
    existingLink.remove();
  }
  
  // Load theme fonts if specified
  const fontsToLoad: string[] = [];
  if (theme.displayFont) fontsToLoad.push(theme.displayFont);
  if (theme.bodyFont && theme.bodyFont !== theme.displayFont) {
    fontsToLoad.push(theme.bodyFont);
  }
  
  if (fontsToLoad.length > 0) {
    loadGoogleFonts(fontsToLoad);
    applyFontVariables(theme.displayFont, theme.bodyFont);
    
    // Persist to localStorage for consistency
    if (theme.displayFont) {
      localStorage.setItem('testFont-sansSerif', theme.displayFont);
    }
    if (theme.bodyFont) {
      localStorage.setItem('testFont-serif', theme.bodyFont);
    }
  }
  
  // If no filename, we're using the default (tokens.css)
  if (!theme.filename) {
    return Promise.resolve();
  }
  
  // Create and append the new theme stylesheet
  const link = document.createElement('link');
  link.id = 'custom-theme-css';
  link.rel = 'stylesheet';
  link.href = `/themes/${theme.filename}`;
  
  return new Promise((resolve, reject) => {
    link.onload = () => resolve();
    link.onerror = () => reject(new Error(`Failed to load theme: ${theme.filename}`));
    document.head.appendChild(link);
  });
}

/**
 * Unload the current custom theme and revert to default
 */
export function unloadTheme(): void {
  const existingLink = document.getElementById('custom-theme-css');
  if (existingLink) {
    existingLink.remove();
  }
}

/**
 * Clear the theme cache (useful for development)
 */
export function clearThemeCache(): void {
  cachedThemes = null;
  loadPromise = null;
}

